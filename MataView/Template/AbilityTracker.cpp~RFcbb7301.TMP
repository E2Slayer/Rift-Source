#include "stdafx.h"
#include "AbilityTracker.h"



//
// Used for drawing a circle with the default direction vector.
//
SDKVECTOR _g_DirectionVector = { 0, 0, 1.f };

//
// Colors in the BGRA format.
//
SDKCOLOR _g_ColorWhite = { 255, 255, 255, 255 };
SDKCOLOR _g_ColorYellow = { 0, 255, 255, 255 };
SDKCOLOR _g_ColorGreen = { 0, 255, 0, 255 };
SDKCOLOR _g_ColorRed = { 0, 0, 255, 255 };
SDKCOLOR _g_ColorPurple = { 128, 0, 128, 255 };


///This gets called once, at load
void AbilityTracker::Init() 
{
	//CurrentTarget = AttackableUnit();
	//OrbTarget = NULL;

#pragma region RegisterCallbacks
	pSDK->EventHandler->RegisterCallback(CallbackEnum::Tick, AbilityTracker::Tick);
	pSDK->EventHandler->RegisterCallback(CallbackEnum::Update, AbilityTracker::Update);
	pSDK->EventHandler->RegisterCallback(CallbackEnum::Overlay, AbilityTracker::DrawMenu);
	pSDK->EventHandler->RegisterCallback(CallbackEnum::Update, AbilityTracker::Draw);
	//pSDK->EventHandler->RegisterCallback(CallbackEnum::CreateObject, AbilityTracker::OnCreate);
	//pSDK->EventHandler->RegisterCallback(CallbackEnum::DeleteObject, AbilityTracker::OnDelete);
	//pSDK->EventHandler->RegisterCallback(CallbackEnum::BuffUpdate, AbilityTracker::OnBuffCreateDelete);
#pragma endregion

}

struct abilityTrackList
{
	abilityTrackList(const char* _champName, const char* _displayName, const char* _objectName, float _time, const char* _menuName, bool _settingEnabler, bool _menuCreator)
	{
		champName = _champName;
		displayName = _displayName;
		objectName = _objectName;
		time = _time;
		menuName = _menuName;
		settingEnabler = _settingEnabler;
		menuCreator = _menuCreator;
	}

	const char* champName;
	const char* objectName;
	const char* displayName;
	float time;
	bool settingEnabler;
	bool menuCreator;
	const char* menuName;
};

struct drawCollector
{
	drawCollector(void* _Object, unsigned _netId, SDKVECTOR _Position, float _TimeLeft, float _CastedTime)
	{
		Object = _Object;
		Position = _Position;
		TimeLeft = _TimeLeft;
		CastedTime = _CastedTime;
		netId = _netId;
	}

	void* Object;
	unsigned netId;
	//int TeamID;

	SDKVECTOR Position;

	float TimeLeft;
	float CastedTime;
};

struct menuCreator
{
	menuCreator(const char* _champName, bool _enabler)
	{
		champName = _champName;
		enabler = _enabler;
		
	}
	const char* champName;
	bool enabler;

};


struct
{
	//
	// Whether we should draw the attack range of a turret.
	//
	bool bMySkills;

	//
	// Whether we should draw the attack radius of only enemy turrets.
	//
	bool bAllySkills;
	bool bEnemySkills;

	bool bChampionList;
	bool bMicsList;
	float iFontSize;

	SDKVECTOR m_CurrentColor;

	float m_A, m_B, m_G, m_R;

	//	for (auto &element : AbilityDictionary) // access by reference to avoid copying
		//{
		//	SdkUiCheckbox(element.displayName, &(element.settingEnabler), NULL);
	//
		//}
} _g_CheckTeamAbilities;


std::vector<abilityTrackList> AbilityDictionary; // List for ability to draw
std::vector<drawCollector> ObjectStore; // Container for drawing to draw now
std::vector<menuCreator> bAbilitySettings; // Container for champion list based menus. 


void AblitiesAdder()
{

	AbilityDictionary.clear(); //clear the list

	//AbilityDictionary.push_back(abilityTrackList("Veigar", "Veigar E", "Veigar_Base_E_Warning_Green", 3.5f, "MataView_VeigarE", true));
	AbilityDictionary.push_back(abilityTrackList("Veigar", "Veigar E (Ally)", "Veigar_Base_E_cage_green", 3.0f, "MataView_VeigarE", true, false));
	AbilityDictionary.push_back(abilityTrackList("Veigar", "Veigar W (Ally)", "Veigar_Base_W_cas_green", 1.2f, "MataView_VeigarW", true, false));
	AbilityDictionary.push_back(abilityTrackList("Veigar", "Veigar E (Enemy)", "Veigar_Base_E_cage_red", 3.0f, "MataView_VeigarE2", true, false));
	AbilityDictionary.push_back(abilityTrackList("Veigar", "Veigar W (Enemy)", "Veigar_Base_W_cas_red", 1.2f, "MataView_VeigarW2", true, false));




	AbilityDictionary.push_back(abilityTrackList("Misc", "Zhonya's Hourglass", "ItemZhonya_Base_stasis.troy", 2.5f, "MataView_Zhonya", true, false));

	AbilityDictionary.push_back(abilityTrackList("Misc", "Guardian Angel", "LifeAura.troy", 4.0f, "MataView_GA", true, false));
	AbilityDictionary.push_back(abilityTrackList("Misc", "Redemption (Ally)", "Item_Redemption_indicator_green.troy", 2.5f, "MataView_Redemption", true, false));
	AbilityDictionary.push_back(abilityTrackList("Misc", "Redemption (Enemy)", "Item_Redemption_indicator_red.troy", 1.5f, "MataView_Redemption2", true, false));


	AbilityDictionary.push_back(abilityTrackList("Zilean", "Zilean R", "Zilean_Base_R_tar_01", 5.0f, "MataView_ZileanR", true, false));

	AbilityDictionary.push_back(abilityTrackList("Akali", "Akali W", "Akali_Base_W_Cas", 5.0f, "MataView_AkaliW", true, false));

	AbilityDictionary.push_back(abilityTrackList("Alistar", "Alistar R", "Alistar_Base_R_cas", 7.0f, "MataView_AlistarR", true, false));

	AbilityDictionary.push_back(abilityTrackList("Braum", "Braum E", "Braum_Base_E_Shield_cas", 3.0f, "MataView_BraumE", true, false));
	//AbilityDictionary.push_back(abilityTrackList("DrMundo", "DrMundo E", "DrMundo_Base_R_cas_02", 12.0f));
	AbilityDictionary.push_back(abilityTrackList("Ekko", "Ekko W", "Ekko_Base_W_Indicator", 3.0f, "MataView_EkkoW1", true, false));
	AbilityDictionary.push_back(abilityTrackList("Ekko", "Ekko W2", "Ekko_Base_W_Cas", 1.0f, "MataView_EkkoW2", true, false));
	//AbilityDictionary.push_back(abilityTrackList("Zed", "Zed W", "Zed_Base_Shadow_TC_Red", 5.0f));
	AbilityDictionary.push_back(abilityTrackList("Zed", "Zed W", "Zed_Base_W_cloneswap_buf", 5.0f, "MataView_ZedW", true, false));
	AbilityDictionary.push_back(abilityTrackList("Zed", "Zed R", "Zed_Base_R_cloneswap_buf", 6.0f, "MataView_ZedR", true, false));

	//AbilityDictionary.push_back(abilityTrackList("Fizz", "Fizz E", "Fizz_Base_E1_Indicator_Ring", 1.0f, "MataView_FizzE", true, false));
	AbilityDictionary.push_back(abilityTrackList("Fizz", "Fizz R (Ally)", "Fizz_Base_R_Ring_Green", 2.0f, "MataView_FizzR", true, false));
	AbilityDictionary.push_back(abilityTrackList("Fizz", "Fizz R (Enemy)", "Fizz_Base_R_Ring_Red", 2.0f, "MataView_FizzR2", true, false));
	AbilityDictionary.push_back(abilityTrackList("Fiddlesticks", "Fiddlesticks R (Ally)", "Fiddlesticks_Base_Crowstorm_green_cas", 5.0f, "MataView_FiddR", true, false));
	AbilityDictionary.push_back(abilityTrackList("Fiddlesticks", "Fiddlesticks R (Enemy)", "Fiddlesticks_Base_Crowstorm_red_cas", 5.0f, "MataView_FiddR2", true, false));
	AbilityDictionary.push_back(abilityTrackList("Janna", "Janna R (Ally)", "Janna_Base_R_cas_Green", 3.0f, "MataView_JannaR", true, false));
	AbilityDictionary.push_back(abilityTrackList("Janna", "Janna R (Enemy)", "Janna_Base_R_cas_Red", 3.0f, "MataView_JannaR2", true, false));
	AbilityDictionary.push_back(abilityTrackList("Jax", "Jax E", "JaxCounterStrike", 2.0f, "MataView_JaxE", true, false));
	AbilityDictionary.push_back(abilityTrackList("Elise", "Elise E (Ally)", "Elise_Base_Spider_E_indicator_green", 2.0f, "MataView_ElieseE", true, false)); //possible replacement Elise_Base_Spider_E_cas 
	AbilityDictionary.push_back(abilityTrackList("Elise", "Elise E (Enemy)", "Elise_Base_Spider_E_indicator_red", 2.0f, "MataView_ElieseE", true, false)); //possible replacement Elise_Base_Spider_E_cas 


	AbilityDictionary.push_back(abilityTrackList("Annie", "Annie R", "annierburnaura", 45.0f, "MataView_AnnieR", true, false));
	AbilityDictionary.push_back(abilityTrackList("DrMundo", "DrMundo E", "Sadism", 12.0f, "MataView_MundoR", true, false));
	AbilityDictionary.push_back(abilityTrackList("Gangplank", "Gangplank R (Ally)", "Gangplank_Base_R_AoE_Green", 8.0f, "MataView_GangplankR", true, false));
	AbilityDictionary.push_back(abilityTrackList("Gangplank", "Gangplank R (Enemy)", "Gangplank_Base_R_AoE_Red", 8.0f, "MataView_GangplankR2", true, false));

	AbilityDictionary.push_back(abilityTrackList("Karthus", "Karthus R (Ally)", "Karthus_Base_R_Target_Green", 3.0f, "MataView_KarthusR", true, false));
	AbilityDictionary.push_back(abilityTrackList("Karthus", "Karthus R (Enemy)", "Karthus_Base_R_Target_Red", 3.0f, "MataView_KarthusR", true, false));
	AbilityDictionary.push_back(abilityTrackList("Nasus", "Nasus R", "Nasus_Base_R_Aura", 15.0f, "MataView_NasusR", true, false));
	AbilityDictionary.push_back(abilityTrackList("Morgana", "Morgana E", "Morgana_Base_E_Tar", 5.0f, "MataView_MorganaE", true, false));
	AbilityDictionary.push_back(abilityTrackList("Morgana", "Morgana R", "Morgana_base_R_Indicator_Ring", 3.0f, "MataView_MorganaR", true, false));
	AbilityDictionary.push_back(abilityTrackList("Nunu", "Nunu W", "Nunu_Base_W_Snowball_RollingBall", 10.0f, "MataView_NunuW", true, false));
	AbilityDictionary.push_back(abilityTrackList("Nunu", "Nunu R", "Nunu_Base_R_Cas", 3.0f, "MataView_NunuR", true, false));
	AbilityDictionary.push_back(abilityTrackList("Ryze", "Ryze R (Ally Caster)", "Ryze_Base_R_Start_Ally", 2.0f, "MataView_RyzeR", true, false));
	AbilityDictionary.push_back(abilityTrackList("Ryze", "Ryze R (Ally Direction)", "Ryze_Base_R_End_Ally", 3.0f, "MataView_RyzeR2", true, false));
	AbilityDictionary.push_back(abilityTrackList("Ryze", "Ryze R (Enemy Caster)", "Ryze_Base_R_Start_Enemy", 2.0f, "MataView_RyzeR3", true, false));
	AbilityDictionary.push_back(abilityTrackList("Ryze", "Ryze R (Enemy Direction)", "Ryze_Base_R_End_Enemy", 3.0f, "MataView_RyzeR4", true, false));

	AbilityDictionary.push_back(abilityTrackList("Tryndamere", "Tryndamere R", "UndyingRage", 5.0f, "MataView_TryndamereR", true, false));
	//AbilityDictionary.push_back(abilityTrackList("Talon", "Talon R", "Talon_Base_R_Cas", 2.5f, "MataView_TalonR", true, false));
	AbilityDictionary.push_back(abilityTrackList("Sion", "Sion R", "Sion_Base_R_Cas", 8.0f, "MataView_SionR", true, false));

	AbilityDictionary.push_back(abilityTrackList("Vladimir", "Vladimir W", "Vladimir_Base_W_buf", 2.0f, "MataView_VladimirW", true, false));
	AbilityDictionary.push_back(abilityTrackList("Taric", "Taric R", "Taric_Base_R_Indicator", 2.5f, "MataView_TaricR", true, false));
	AbilityDictionary.push_back(abilityTrackList("Taric", "Taric R (Invulnerable)", "Taric_Base_R_buf", 2.5f, "MataView_TaricR2", true, false));

	AbilityDictionary.push_back(abilityTrackList("Rammus", "Rammus Q", "PowerBall", 6.0f, "MataView_RammusQ", true, false));
	//AbilityDictionary.push_back(abilityTrackList("Vladimir", "Vladimir W", "Vladimir_Base_W_buf", 2.0f, "MataView_VladimirW", true, false));


	//Nasus_Base_R_Aura

	//Gangplank_Base_R_AoE_Green

	//time is z Tryndamere_Base_R_glow_01 
	//Janna_Base_R_cas_Green





	std::sort(AbilityDictionary.begin(), AbilityDictionary.end(), [](const abilityTrackList& lhs, const abilityTrackList& rhs) {
		return std::strcmp(lhs.champName, rhs.champName) < 0;
	});

	for (auto &element : AbilityDictionary) // access by reference to avoid copying
	{

		std::string t1(element.champName);

		auto it = std::find_if(
			bAbilitySettings.begin(), bAbilitySettings.end(),
			[&element](const menuCreator& x) { return std::strcmp(x.champName, element.champName) == 0; });
		if (it != bAbilitySettings.end())
		{
			//SdkUiConsoleWrite("[added] %s  \n", "dont do it");
		}
		else
		{
			bAbilitySettings.push_back(menuCreator(element.champName, false));
			//SdkUiConsoleWrite("[added] %s  \n", element.champName);
		}

	}

	//std::sort(bAbilitySettings.begin(), bAbilitySettings.end());
	//bAbilitySettings.erase(std::unique(bAbilitySettings.begin(), bAbilitySettings.end()), bAbilitySettings.end());
}

///This gets called 30 times per second, put your logics in here instead of
///on OnUpdate so it doesnt drop too many fps
void AbilityTracker::Tick(void * UserData) 
{


}

///This gets called X times per second, where X is your league fps.
///Use this only to update stuff you need to validade on every frame.
void AbilityTracker::Update(void * UserData) 
{
	
}

///This gets called X times per second, where X is your league fps.
///Put any drawings you need here
void AbilityTracker::Draw(void * UserData) 
{

	
}

///Your menu settings go here
void AbilityTracker::DrawMenu(void * UserData) 
{
	UNREFERENCED_PARAMETER(UserData);

	bool bAbilityExpanded = true;
	Menu::Tree("Ability Tracker", "Ability.Main", &bAbilityExpanded, []()
	{
		SdkUiText("MataView 1.1 [Beta] - E2Slayer");
		bool bSettingsExpanded = false;
		Menu::Tree("Settings", "Ability.Settings", &bSettingsExpanded, []()
		{
			Menu::SliderInt("Font Size", "Ability.FontSize", 28, 21, 50); //&_g_CheckTeamAbilities.iFontSize, 21.0f, 50.0f, "%.0f", NULL);
			SDKVECTOR defaultColor = { 255, 255, 255 };
			Menu::ColorPicker("Color Picker", "Ability.Color", defaultColor);
			
			//MakeMenu::ColorPicker()
			//SdkUiColorPicker("Color Pick", &_g_CheckTeamAbilities.m_CurrentColor, NULL);
			//SdkUiText("Note: The settings work after pressed the Save Settings");
			SdkUiColoredText(&_g_ColorGreen, "Note: The settings will apply \nAfter pressed the Save Settings");
			

		});


		bool bChampionListExpanded = false;
		Menu::Tree("Settings", "Ability.Settings", &bChampionListExpanded, []()
		{
			Menu::SliderInt("Font Size", "Ability.FontSize", 28, 21, 50); //&_g_CheckTeamAbilities.iFontSize, 21.0f, 50.0f, "%.0f", NULL);
			SDKVECTOR defaultColor = { 255, 255, 255 };
			Menu::ColorPicker("Color Picker", "Ability.Color", defaultColor);

			//MakeMenu::ColorPicker()
			//SdkUiColorPicker("Color Pick", &_g_CheckTeamAbilities.m_CurrentColor, NULL);
			//SdkUiText("Note: The settings work after pressed the Save Settings");
			SdkUiColoredText(&_g_ColorGreen, "Note: The settings will apply \nAfter pressed the Save Settings");


		});


		bool bChampionListExpanded = false;
		SdkUiBeginTree("Champions", &bChampionListExpanded);
		if (bChampionListExpanded)
		{

			for (auto& element1 : bAbilitySettings) // access by reference to avoid copying
			{
				if (std::strcmp(element1.champName, "Misc") != 0)
				{
					//const char* t1 = element.
					SdkUiBeginTree((element1).champName, &element1.enabler);
					if (element1.enabler)
					{
						for (auto &element2 : AbilityDictionary) // access by reference to avoid copying
						{
							if (std::strcmp(element1.champName, element2.champName) == 0)
							{
								SdkUiCheckbox(element2.displayName, &element2.settingEnabler, NULL);
								//SdkUiConsoleWrite("[added] %s  \n", element.champName);
							}
						}
						SdkUiEndTree();
					}
				}


			}
			SdkUiEndTree();
		}



	});


	/*
	Menu::Tree("Ability Tracker", "Ability", &bAbilityExpanded, nullptr);


	SdkUiBeginTree("Ability Tracker", &bAbilityExpanded);
	if (bAbilityExpanded)
	{



		bool bSettingsExpanded = false;
		SdkUiBeginTree("Settings", &bSettingsExpanded);
		if (bSettingsExpanded)
		{


			SdkUiDragFloat("Font Size", &_g_CheckTeamAbilities.iFontSize, 21.0f, 50.0f, "%.0f", NULL);
			SdkUiColorPicker("Color Pick", &_g_CheckTeamAbilities.m_CurrentColor, NULL);
			//SdkUiText("Note: The settings work after pressed the Save Settings");
			SdkUiColoredText(&_g_ColorGreen, "Note: The settings will apply \nAfter pressed the Save Settings");
			SdkUiEndTree();
		}

		//	sdkui
			//
		bool bChampionListExpanded = false;
		SdkUiBeginTree("Champions", &bChampionListExpanded);
		if (bChampionListExpanded)
		{

			for (auto& element1 : bAbilitySettings) // access by reference to avoid copying
			{
				if (std::strcmp(element1.champName, "Misc") != 0)
				{
					//const char* t1 = element.
					SdkUiBeginTree((element1).champName, &element1.enabler);
					if (element1.enabler)
					{
						for (auto &element2 : AbilityDictionary) // access by reference to avoid copying
						{
							if (std::strcmp(element1.champName, element2.champName) == 0)
							{
								SdkUiCheckbox(element2.displayName, &element2.settingEnabler, NULL);
								//SdkUiConsoleWrite("[added] %s  \n", element.champName);
							}
						}
						SdkUiEndTree();
					}
				}


			}
			SdkUiEndTree();
		}


		bool bMicsListExpanded = false;
		SdkUiBeginTree("Misc", &bMicsListExpanded);
		if (bMicsListExpanded)
		{

			for (auto& element1 : bAbilitySettings) // access by reference to avoid copying
			{
				if (std::strcmp(element1.champName, "Misc") == 0)
				{
					//const char* t1 = element.


					for (auto &element2 : AbilityDictionary) // access by reference to avoid copying
					{
						if (std::strcmp(element1.champName, element2.champName) == 0)
						{
							SdkUiCheckbox(element2.displayName, &element2.settingEnabler, NULL);
							//SdkUiConsoleWrite("[added] %s  \n", element.champName);
						}
					}


				}


			}
			SdkUiEndTree();
		}


		SdkUiEndTree();
	}

	bool SaveClicked = false;
	SdkUiButton("Save settings", &SaveClicked);
	if (SaveClicked)
	{
		//
		// Save these settings.
		//

		AwSaveSettings();
	}

	bool ReloadClicked = false;
	SdkUiButton("Reload settings", &ReloadClicked);
	if (ReloadClicked)
	{
		//
		// Reload effectively loads the saved values directly from
		// the module-specific configuration store.
		//

		AwLoadSettings();
	}
	*/
}

